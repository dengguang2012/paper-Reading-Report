---
layout: post
title: The Scalable Commutativity Rule
categories:
- life
tags:
- technology
- 
---

##The Scalable Commutativity Rule

The Scalable Commutativity Rule: Designing Scalable Software for Multicore Processors 阅读报告

在接口方面，例如一些系统调用的API，还有哪些对于可扩展性是潜在的机会，可扩展性的时机能够在不进行具体实现仅仅考虑接口规范的情况下定义吗，为了回答这些问题，
论文介绍了下面的规则，无论接口操作什么时候交换，它们都可以用一种可扩展的方式实现。这条规则帮助开发者在从接口的设计和实施到具体实现，测试和评测的过程中构建可扩展性更强的软件。
为了帮助开发者应用这条规则，一个新的名为Commuter的工具采纳高级接口模型并且生成可以交换而可以扩展的操作测试，使用这些测试案例，commuter可以评估实现的可扩展性。
我们应用commuter到18POSIX调用，使用结果来指导一个新的名为sv6的操作系统内核的设计实现。

评估多核可扩展性软件的艺术状态是选择能够展示不等数量内核性能的工作量，使用一些工具，例如differential profiling这样的软件来量化可扩展性瓶颈。
这将使得开发者聚焦于真正的问题上面，但是也有一些缺点，不同的负载或者更高的核心总数常常显示新的瓶颈，而对于哪些瓶颈是基本的问题这是不清楚的，
所以开发者还没有意识到可扩展性解决方法就放弃了，最终这个进程在整个开发流程中发生的太晚这个设计级别的解决方案例如改善接口可能是不实际的。

针对多核处理器的软件扩展性，一般作为实际问题来解决。一旦软件实施各种基准测试，可以发现该接口和相关的环境的瓶颈，这也限制了软件可扩展性。作者认为，
在设计阶段即固定软件是一个问题，并提出解决方案，在实施阶段，发现接口的可扩展性和贡献软件扩展性。

这篇论文中提出的方法是使扩展性开始于更高的层次：软件接口。这会使得在实施存在之前和必要的硬件可以获取之前来测试可扩展性的实现。这能够高亮潜在的可扩展性问题，
导致额外的接口设计，并且也对可扩展接口的实现设置了一个扩展目标。本文的主要贡献是SIM交换性规则。研究人员发现简单的代数交换定义过于严格。相反，他们创造了一个定义，
说如果在H历史Y SIM交流，存在一个正确实施，使得该地区Y是没有冲突。这意味着，存储器访问是在高速缓存行的区域相互排斥的，这意味着该接口可以扩展。
 SIM的交换性，特别是指一个操作必须是状态相关，基于接口的，并且单调。在一般层次中，动作序列的SIM通信（相继扩展）如果这些操作可以以任何方式被重新排列，
 以产生相同的结果。首先是要分解合成的操作。 POSIX API往往包含并不相互通信的若干子操作。如果可能的话，这些操作应该分开。二是包含不确定性规范。这允许较少的同步，
 和更多的并发。第三，许多接口要求严格的排序，这限制只有微弱的顺序可能是必要时候的交换。最后，释放异步资源意味着可以停止高昂的同步，并且可交换可以再次提高。
 而对于commute系统，它允许开发者在实现进程之前指定接口。commute可以确定使用这些接口通信的测试用例。结果是开发者可以实现进程之前做出全局接口改变来改善可扩展性。

可扩展的交换规则的精确定义是什么，为什么规则是正确的？作者回答这些问题使用基于抽象的行动，历史，及实现方法。
形式主义依赖SIM通信交换，其通用性扩大了规则的适用于复杂的软件接口。作者建设性的证通信规则，也揭示了一些实现可能建成的通信，当然实际建设不是很实用。
在早期的工作，建模的系统执行作为一个序列的行动，其中动作要么是调用要么是回应。在操作系统的上下文中，一个调用，是一个有观点的系统调用（如getpid()（或打开“文件”，o_rdwr））和响应代表相应的结果（PID或文件描述符）。
调用和响应配对。每个调用都是由一个特定的线程，和相应的响应返回到相同的线程。因此，包括一个操作类（例如，哪一个系统调用被调用）；（2）操作参数（用于调用）或返回值（回应）；（3）相关的线程；和（4）是唯一一个标签。
我们将要写调用左半周期（“调用”）和反应为右半周期（“反应”），在字母匹配调用和响应。和垂直偏移区分线程：在不同的线程中执行调用系统称为历史。例如：H = abcacbddeefghfhgwe会考虑形成好的历史，其中每个线程的行动序列的形式调用回复组合.
上面的H以及形成；检查threadt为红色，我们看到的线程限制subhistoryh | T = aaddhhformed通过selectingt的actionsfromhalternates调用和响应作为一个希望。在一个良好的历史，每个线程调用最多存在突出的一点。thespecificationdistinguishes是否保守党是“正确的”。
一个specificationsis一形成良好的历史closedset前缀。其内容取决于系统建模；例如，ifsspecified UNIX这样的操作系统，
然后getpid() [ a，a 0 ]̸∈，因为nounix线程可以有PID 0。我们的定义和proofrequire一些规范的存在，但我们并不关注它是如何构建。


交换应该捕捉顺序动作的集合不要紧的想法。这是后面的行为不能告诉实际发生的顺序。规格有助于使这种精确的：
一一系列的操作在某些上下文时当规格保持冷漠对于设定的执行顺序。这意味着对任何命令的交换设置任何响应有效期一阶的交换的有效性，
并响应一阶无效无效的任何命令。但交换的正确定义是一个有点棘手，所以我们建立了两步。一个动作序列，或区域是H'记录行动序列，H|t = H′|t对于每一个线程。因此，区域h包含相同的交流，但可能交织线程不同。因为它不行动，INH的红线不尊重秩序。

为了实现可扩展性的原因，我们需要模拟实现足够的细节来告诉whetherdifferent线程”的内存访问“无冲突。
（如冲突的自由是我们为可扩展性的代理讨论）我们定义一个实现为一个阶梯函数：给定一个状态和调用，它产生一个新和响应。
特别的行为使能同时的重叠的业务阻塞。我们首先定义三个集合：SIS执行状态的集合。IIS的有效调用，设置包含持续 RIS的有效反应，设定包含持续，实现mis功能插件，旧状态和调用，
一个新的实现过程状态和响应（在响应中一定有线程调用相同）。这继续表明那个线程真实反应尚未准备好，并允许实施有效地切换到另一个线程。持续调用给实施的契机，完成未完成的请求（或进一步延迟反应）；
然而，响应必须是线程匹配持续调用.实现的一代历史通话时要实施（也许包含持续职业）可能产生的相符合的历史。

对于设计通信接口，规则有利于扩展性推理在接口规范的水平，和SIM交换让应用复杂的接口规则。这部分验证接口级推理的规则启用。
使用POSIX作为一个案例研究中，我们探讨的变化使操作在更多的情况下通信，使能更多的可扩展性的实现。已经很多posix操作与许多其他操作通信，一个顾客将在下一部分量化；这一部分主要问题的情况下，提供一种更加微妙的问题交换接口设计。

分解操作。许多posix apis结合多个操作为一体，综合操作的限制性。例如，fork不仅创建一个新的进程和快照，
当前过程的整个内存状态，文件描述符的状态，信号掩码，和几个其他属性。作为一个结果，fork不能通信在同一过程中大多数其他操作，如存储器的写操作，地址空间操作，和多个文件描述符的操作。然而，应用程序往往遵循fork 和 exec，撤消大多数fork的子操作。与只有fork和exec，应用被迫接受这些不必要的子操作，限制通信。

拥抱规范非决定论，允许弱的订单，异步释放资源。

在使用commuter 分析接口时候，充分认识界面复杂的交换性是棘手的，
完成一个实现避免共享操作时避免添加到一个已经困难的任务。然而，通过杠杆老化的交换规则的形式，
开发培训计划可以自动化这个推理。这部分系统对称，测试驱动的方法来利用交换规则，真正实现体现在工具称为commuter，其组成如图3。
首先，分析器使用符号模型的界面和计算下，接入的业务上精确的条件。其次，testgen使用这些条件和产生的操作，
上下文按接口具体的测试用例，因此应根据交换规律有无冲突的实现。第三、检测是否一个特定的实现无冲突对于每一个测试案例。

<img src="https://github.com/dengguang2012/paper-Reading-Report/blob/master/illustraction/28.jpg" style="width: 50%; height: 50%"/>​


作者对sv6进行了评估，一个带有很大可扩展内存文件系统和一个新的虚拟内存系统的实验性质的操作系统。
对比POSIX实现的接口，sv6为99%的情况实现可扩展性，这与POSIX接口仅仅与68%的情况没有冲突。基准数据也对比这两种性能。