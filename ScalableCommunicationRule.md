---
layout: post
title: The Scalable Commutativity Rule
categories:
- life
tags:
- technology
- 
---

##The Scalable Commutativity Rule

The Scalable Commutativity Rule: Designing Scalable Software for Multicore Processors 阅读报告

在接口方面，例如一些系统调用的API，还有哪些对于可扩展性是潜在的机会，可扩展性的时机能够在不进行具体实现仅仅考虑接口规范的情况下定义吗，为了回答这些问题，
论文介绍了下面的规则，无论接口操作什么时候交换，它们都可以用一种可扩展的方式实现。这条规则帮助开发者在从接口的设计和实施到具体实现，测试和评测的过程中构建可扩展性更强的软件。
为了帮助开发者应用这条规则，一个新的名为Commuter的工具采纳高级接口模型并且生成可以交换而可以扩展的操作测试，使用这些测试案例，commuter可以评估实现的可扩展性。
我们应用commuter到18POSIX调用，使用结果来指导一个新的名为sv6的操作系统内核的设计实现。

评估多核可扩展性软件的艺术状态是选择能够展示不等数量内核性能的工作量，使用一些工具，例如differential profiling这样的软件来量化可扩展性瓶颈。
这将使得开发者聚焦于真正的问题上面，但是也有一些缺点，不同的负载或者更高的核心总数常常显示新的瓶颈，而对于哪些瓶颈是基本的问题这是不清楚的，
所以开发者还没有意识到可扩展性解决方法就放弃了，最终这个进程在整个开发流程中发生的太晚这个设计级别的解决方案例如改善接口可能是不实际的。

针对多核处理器的软件扩展性，一般作为实际问题来解决。一旦软件实施各种基准测试，可以发现该接口和相关的环境的瓶颈，这也限制了软件可扩展性。作者认为，
在设计阶段即固定软件是一个问题，并提出解决方案，在实施阶段，发现接口的可扩展性和贡献软件扩展性。

这篇论文中提出的方法是使扩展性开始于更高的层次：软件接口。这会使得在实施存在之前和必要的硬件可以获取之前来测试可扩展性的实现。这能够高亮潜在的可扩展性问题，
导致额外的接口设计，并且也对可扩展接口的实现设置了一个扩展目标。本文的主要贡献是SIM交换性规则。研究人员发现简单的代数交换定义过于严格。相反，他们创造了一个定义，
说如果在H历史Y SIM交流，存在一个正确实施，使得该地区Y是没有冲突。这意味着，存储器访问是在高速缓存行的区域相互排斥的，这意味着该接口可以扩展。
 SIM的交换性，特别是指一个操作必须是状态相关，基于接口的，并且单调。在一般层次中，动作序列的SIM通信（相继扩展）如果这些操作可以以任何方式被重新排列，
 以产生相同的结果。首先是要分解合成的操作。 POSIX API往往包含并不相互通信的若干子操作。如果可能的话，这些操作应该分开。二是包含不确定性规范。这允许较少的同步，
 和更多的并发。第三，许多接口要求严格的排序，这限制只有微弱的顺序可能是必要时候的交换。最后，释放异步资源意味着可以停止高昂的同步，并且可交换可以再次提高。
 而对于commute系统，它允许开发者在实现进程之前指定接口。commute可以确定使用这些接口通信的测试用例。结果是开发者可以实现进程之前做出全局接口改变来改善可扩展性。

作者对sv6进行了评估，一个带有很大可扩展内存文件系统和一个新的虚拟内存系统的实验性质的操作系统。
对比POSIX实现的接口，sv6为99%的情况实现可扩展性，这与POSIX接口仅仅与68%的情况没有冲突。基准数据也对比这两种性能。



