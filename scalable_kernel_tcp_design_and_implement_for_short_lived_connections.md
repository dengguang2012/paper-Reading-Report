---
layout: post
title: fastsocket
categories:
- paper
tags:
- technology
- 
---

##fastsocket

Scalable Kernel TCP Design and Implementation for Short-Lived Connections阅读报告

### 背景介绍

随着网络带宽的迅速增长，一台机器上CPU内核数量和应用API模型的增加对于短连接提出了需求，一个可扩展的TCP协议栈是提升性能的关键。
虽然许多clean-state的设计已被提出，但是产品环境还需要设计自下而上的并行TCP协议栈，使得向后兼容现有的应用程序。作者提出一个fastsocket，BSD socket兼容和可扩展性内核socket设计，
在TCP协议栈达到了表级别的分区，并且保证了主动与被动的连接局部性。fastsocket架构是本质的分区设计，从网络接口控制其中断一直到应用程序，都能够自然地在整个堆栈消除了各种锁争议。
此外，fastsocket保持内核的TCP协议栈和BSD套接字兼容API的全部功能，应用程序因此不需要修改。

而作者的评估显示，fastsocket在24核机器上面短连接负载下达到加速20.4x，优于国家的最先进的Linux内核的TCP实现。当扩展到24个CPU内核时候，fastsocket在Nginx和HAProxy上面的吞吐量与基础Linux内核的比较分别增加267%和621%。
证明fastsocket可以同时实现可扩展性和维护BSD套接字API。FastSocket已经部署在sina weibo的产品环境中，服务于5000万日常活跃的用户和每天数十亿的请求。

近年来，移动设备和应用程序快速增长。这些新的移动应用程序产生大量的网络负载构成TCP短连接。HTTP是一个典型的TCP短连接源头。例如，在新浪微博，一个调用大量的HTTP接口的典型要求的长度大约是600个字节，
相应的响应的长度通常是1200字节。请求和响应只消耗一个单一的IP数据包，在两组数据交换完成，连接被关闭，这是短连接的特点。在这种情况下，TCP连接的建立和终止的速度成为服务器性能关键。
而一个机器CPU内核的数量不断增加，网络协议栈的可扩展性对于多核平台的网络应用程序的性能起着关键的作用。对于长连接新连接的元数据管理不够频繁造成很大的争论。
因此我们并没有看到在这些情况下TCP协议的可扩展性问题。然而，达到短连接同一水平可扩展性是一个挑战，因为它涉及到频繁和开销很大的TCP连接的建立和终止，从而导致在TCP控制块和虚拟文件系统中严重的资源共享冲突。
TCB管理：TCP连接的建立和终止操作涉及到管理就是在Linux内核中由TCP套接字代表的全局TCBs。
这些所有scokets被管理在两个全局哈希表中，称为listen table，establish table。由于这两个表全系统共享，CPU内核之间的同步是不可避免的。

VFS抽象，套接字通过VFS和暴露在用户级应用程序一个socket文件描述符（FD）进行抽象。打开和关闭VFS套接字fd 的性能对TCP连接的建立和终止的效率有直接影响。
然而，在处理VFS共享状态有严重的同步开销，如inode和dentry，导致可扩展性的瓶颈。

在一个8核产品服务器上面运行HAProxy作为HTTP负载平衡器使得微博客户端流量分配到多个服务器的中，这其中会发生严重的锁争用。从收集的性能数据进行分析，我们观察到在TCB和VFS分别占到CPU周期自旋锁消耗总量的9%和11%管理。
更糟糕的是，由于网络堆栈处理内部冲突，在所有的CPU内核有一个明确的负载不平衡，虽然包被网卡均匀地分布到这些CPU内核。

对于全局共享数据结构进行分区，听表建立表；正确引导受到的数据包，实现对任意连接的连接局部性；提供在VFS解决可扩展性问题的快速方法、在VFS上述TCP设计充分保留BSD套接字API。
引入一个内核网络协议栈的设计实现了对TCB管理表分区和实现对任意连接类型局部连接。分区方案完整和自然的解决网络处理潜在冲突的问题，
包括不能直接解的问题比如定时器锁争用。

在内核中进行适当修改，可以建立一个高度可扩展的内核网络协议栈。通过集成到内核框架，
设计可以保持鲁棒性和实现内核网络协议栈的所有功能，这使得它的实际生产环境的部署很实际。
fastsocket遵循这一理念，被大量部署在新浪微博的生产环境。

###挑战

可扩展性的瓶颈主要是TCP控制块管理和虚拟文件系统的抽象。
对于TCP控制块管理，主要是各种锁机制，多个CPU核同时更新该TCBs.
当多个客户端同时请求同一个端口建立主动连接，全局侦听socket就用来在所有的cpu内核上面建立连接。

一个新的套接字创建并添加到建立的表，表示一个已建立的连接的主动与被动的关系连接。Linux目前采用每斗锁同步并发修改了多个CPU内核共享表。
这锁粒度在服务于8核几百个请求时工作还不错。然而，建立表的整体设计将不可避免地导致大量锁冲突时的CPU内核和并行连接在一台服务器上快速增长。
因此，锁的粒度重新细化只是优化，而不是彻底解决可扩展性问题。

一个连接中输入输出数据包可以通过两种不同的CPU内核处理，使CPU缓存弹跳性能降解。
因此，最大的可扩展性，它是理想的实现完全连接的地方，即对于一个给定的连接的所有活动都在同一个CPU核心处理，包括被动和主动的关系。

###fast socket设计方案

<img src="https://github.com/dengguang2012/paper-Reading-Report/blob/master/illustraction/4.jpg" style="width: 50%; height: 50%"/>​

fastsocket由三部分组成，TCB数据结构分区（局部听表和局部建立表），接收流传递（RFD），和fastsocket aware VFS。
三模块合作提供每个核心流程中的所有活动区域，对于一个给定的连接，从网卡中断到访问的应用程序，由一个交叉核同步，单CPU核执行。

建立每核处理区，我们对于共享的数据结构进行了改进，VFS抽象实现和内核连接绑定：
fastsocket完全分配TCB表的数据结构管理。因此，当net_RX softirq达到TCP层，fastsocket使用每核局部侦听表和每核心局部建立表对于全分区TCB的管理。
传入的数据包进入网络堆栈之前，fastsocket使用接收流提供引导分组到一个适当的CPU核，在相应的局部表管理及其相关的应用程序运行。
这样，fastsocket达到最大局部连接和尽量减少CPU缓存超出。3。内核虚拟文件系统层的Socket API的抽象性和兼容性是关键。
fastsocket-aware绕过不必要的密集锁VFS 的例程，使用特殊scoket快速通道而不用消除可扩展性

<img src="https://github.com/dengguang2012/paper-Reading-Report/blob/master/illustraction/5.jpg" style="width: 50%; height: 50%"/>​

作者使用局部侦听表和局部建立表实现表级别的分区侦听sockets并且建立了sockets管理。局部侦听在启动时，
服务器应用程序的第一个过程通常listen()在一个特定的TCP端口等待客户端请求。内核相应地创建一个侦听套接字全局侦听表。
然后服务器建立多进程绑定不同的CPU内核。这些子进程继承侦听套接字， 准备接受新的连接和并行处理接受连接。
使用fastsocket，每个进程调用locallisten()通知内核的进程要处理从CPU核心传入的连接，它已绑定（1）。如图2所示，在CPU核0绑定的进程上面，
一个新的监听套接字从原来的监听套接字复制和插入cpu核0的侦听表（2）。我们指的是复制侦听套接字的LIS和原来的监听套接字作为全局侦听套接字。
在图2所示的步骤（3）至（6）和（8）至（10）设置被动连接使用本地侦听表的主动连接，和步骤（7）、（11）和（12）说明慢（异常）处理故障路径。
使用了快慢结合路径。

对于局部建立表，fastsocket在内核初始化网络协议栈的时候为每个CPU核分配本地建立的表，新建立的sockets插入的局部建立的表。
在net_rx 软中断，内核检查本地建立的表来为任意进入的包匹配创建套接字。
有了局部建立表，建立套接字管理完全在CPU内核划分，无论在单个机器的CPU核心的数量是多少，这种设计消除了在建立表的可伸缩性问题。

另外还使用了接收流传输解决主动连接局部问题达到完全的局部连接。主要是当主动建立连接请求时内核编码当前CPU核ID为源端口。
为了达到这个目的，我们使用一个哈希函数hash（P）映射端口到CPU内核。当应用程序运行在CPU核C试图建立一个有效的连接，选取一个端口，
RFD 使用端口pscr 因此c=hash(psrc)。在接收到响应包，RFD拾起所接收到的数据包决定了CPU核处理数据包hash(psrc)，如果不是CPU核目前处理包将数据包
发送到选定的CPU核。在这种方式下，RFD保证每个活动连接总是由相同的CPU核处理，消除了非本地连接问题。

对于Fastsocket-aware VFS。linux系统使用虚拟文件系统抽象来管理socket。然而,sockets基本不同于磁盘上面的文件。
避免不必要的开销，fastsocket-aware VFS提供了一种快速路径在VFS处理socket，避免不必要的开销。具体来说，fastsocket-aware VFS跳过最初始化/销毁工作，
在创建/销毁dentry和inode的socket，包括获取几个锁和各种表格和链接管理dentry和inode。

为了保持兼容性不能从socket完全删除dentry和inode，避免将打破传统socket的兼容性。
例如，广泛使用的系统工具如lsof和netstat将失败，因为他们访问相应的插socket状态通过/proc文件系统，它依赖于dentry和inode（但不要求他们完全初始化）。
fastsocketa-ware VFS只保留必要的状态和dentry和inode功能支持/proc文件系统，这对于要实现兼容性的开销很小。
总之，fastsocket-aware VFS内部定制接口的提高可扩展性而对外保持VFS兼容Socket应用程序和系统工具。

###评估

在一个8核的服务器上面测试fastscoket,运行HaProxy作为负载均衡，相比基本的linux性能提升很大。

<img src="https://github.com/dengguang2012/paper-Reading-Report/blob/master/illustraction/6.jpg" style="width: 50%; height: 50%"/>​

