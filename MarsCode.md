---
layout: post
title: MarsCode
categories:
- life
tags:
- technology
- 
---

##火星代码阅读报告

[原文地址](http://cacm.acm.org/magazines/2014/2/171689-mars-code/fulltext)

http://cacm.acm.org/magazines/2014/2/171689-mars-code/fulltext

本文对于保证好奇者号火星登陆器到达目的地并且按照需求运转的冗余软件（和硬件）进行了介绍。
控制太阳系内的太空飞船必须按照高标准的可靠性进行设计，任何小的错误会导致任务失败和探索人类智慧极限机会的失败。
软硬件设计的时候都采取了非凡的举措来保证太空飞船的可靠性，并且系统可以进行调试和修改即使是百万公里以外，
正式的方法辅助核实复杂的为了潜在的竞争条件的软件子系统。
 
太空飞船上的嵌入式软件设计为不同寻常的定制的周边设备序列。一个很小的编码错误可能就会导致大量投资打水漂，并且使得相关责任机构蒙羞。
本文介绍了在火星科技实验室软件设计开发中采取的防范措施。对于采用的编程规范，区别于稀疏性质，基于风险的，被一些编译检查工具支持；
第二，我们采取重定义的代码评审过程，彻底高效率净化大量的代码，再次杠杆化工具的使用，第三，逻辑化模型工具正式的检查批判并发相关的任务代码段。
编码标准也对应不同的软件适应不同的标准，一级服从，为所有的写出的代码设置了最小标准，这里也有两条规则，第一条是所有的代码必须服从语法，
不能使用编译器指定的扩展超出语法定义的符号，第二条规则是所有的代码必须通过编译并且没有任何触发警告。LOC-2指的是在嵌入式系统环境中安全可预测的执行。
LOC-3是所有代码长度大于10的时候必须使用异常，LOC-4指的是对于紧急任务代码的目标级别，对于MSL任务包含所有的板子上面的软件。至于基于工具的代码评审，
标准机制使用成对代码评审，在同一代码上面运行多个编译器常常是很有效的，在模板检查中，在兵工厂分析多线程代码最强的类型检查时逻辑模型检查，
火星科学实验室任务的代码大量利用了多线程，用120个线程任务来在一个实时操作系统控制下面执行，潜在的竞争情形存在，已经是对于早先任务很大的影响。
为了彻底分析竞争情形下的代码，我们做了扩展使用逻辑模型检查器Spin，联合一个扩展的c语言代码的模型抽取工具。
模型检查器Spin定义了使用异步执行线程的方法来来验证分布式系统软件。它的内在的验证算法是基于Vardi和Wolper的自动化理论验证方法。
我们分析了几个关键软件部件包括一个双CPU的启动控制算法，非易失性flash文件系统和数据管理子系统，算法决定启动飞船的时候两个CPU哪一个会对飞船进行控制。
这会是没道理的难去手动证明一个并发算法在所有可能的情形下是正确的，我们采取的例子是一个非阻塞的两边队列的算法。算法使用了原子性，双字交换 或者DCAS指令。
检验代码首先定义了一个简单的测试驱动依靠添加或者删除元素训练代码。为了简单，这个例子仅仅使用了pushRight()和popRight活动，我们会实现使用对于读写不同的线程，
即使这些测试仅仅不能建立这个算法正确性。模型检查设计为执行这种类型的检查，使用模型检查需要配置文件来验证应用，命令大约花了12秒时间执行，
其中只有0.02秒有需要来进行验证。其余的运行时间被从源码中提取模型占用，还有Spin来转换模型为优化的c代码，最后对于c编译器来产生可执行运行这个检测，
错误跟踪的重演掩饰了一个竞争情形可以导向一个异常违背因此显示算法的错误。报告被写进程执行标记为W而读进程标记为R。在最初调用初始化initialize，
在sample_writer例程。模型抽取方法允许在简单应用中使用非常简单的类型，也支持保留应用原始的控制数据流，也支持在配置文件中更多的高级抽象函数的定义，
可以用来减少抽取模型复杂性。默认的转换规则定义了从源代码到模型一对一的映射允许直接验证大量多线程的c程序和算法。

飞船在降落到火星表面时没有出现错误，同时达成了主要任务，原理上证明了生命可以在其他星球存在。每次采取的预防措施优化了成功的概率，不只是软件开发过程中，
关键的硬件不见也是备份复制的，包括主cpu是冗余的，如果主要的cpu死机，那么备份版本就是第二机会。
